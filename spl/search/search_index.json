{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Intro SPL is a simple scripting language, which features x86 and BASIC inspired syntax. The language was created as a learning tool into interpreter design. The language features a custom made bytecode platform, which the language compiles to. As of right now, there is no JIT compilation, meaning the language could be sped up by compiling from bytecode to machine code. The language works by pushing values onto the stack, manipulating them, then moving them into variables. This can be used to create some advanced arithmetic. The language is currently only available on Windows, however I would like to port over to Linux in the future. SPL also refers to each bit of code as an instruction, as when they are compiled, they become a single instruction on the virtual processor. SPL has finally reached v1.2, which is expected to be its end of support. Version 1.2 has implemented console manipulation, allowing programs to be more visually impressive See examples for programs that I used these features on. SPL programs can use breakpoints, to allow an easier time debugging. Here's a quick example :loop println \"Hello, World!\" ;See how easy the syntax is =D goto loop","title":"Home"},{"location":"#intro","text":"SPL is a simple scripting language, which features x86 and BASIC inspired syntax. The language was created as a learning tool into interpreter design. The language features a custom made bytecode platform, which the language compiles to. As of right now, there is no JIT compilation, meaning the language could be sped up by compiling from bytecode to machine code. The language works by pushing values onto the stack, manipulating them, then moving them into variables. This can be used to create some advanced arithmetic. The language is currently only available on Windows, however I would like to port over to Linux in the future. SPL also refers to each bit of code as an instruction, as when they are compiled, they become a single instruction on the virtual processor. SPL has finally reached v1.2, which is expected to be its end of support. Version 1.2 has implemented console manipulation, allowing programs to be more visually impressive See examples for programs that I used these features on. SPL programs can use breakpoints, to allow an easier time debugging. Here's a quick example :loop println \"Hello, World!\" ;See how easy the syntax is =D goto loop","title":"Intro"},{"location":"ops/","text":"Instructions Let The let keyword will update the value of a variable, or assign it if it does not exist. ;This will create x let x \"SPL\" let x \"New Value\" ;This will update the value of x All variables must be created before use. push x ;This will fail since x has not been created yet let x 1 push x ;This is ok because x has already been created Setpop setpop is similar to the let keyword, however it will take the value of the variable from the stack instead of being given an explicit value. push 3.1415 setpop pi ;pi now contains 3.1415 setpop will operate on variables that already exist and have not been defined push 0 let x 0 setpop x push 0 setpop y ;Even though y has not been defined, setpop will create it Print Printing uses two different keywords. print and println . As you might be able to guess from the name, println will print with a new line character appended at the end of the output. print \"Hello\" println \" There \" print \"World!\" ;This will display this in the console: ;Hello There ;World! Printing also works with all data types and variables let x \"Hello\" println x print \"Hello\" print 1 print 3.1415 Calling SPL uses two keywords to deal with calling. goto and call are the two main instructions used. goto will jump to a set code point. call does the same, except it will add to the callstack which allows you to return back to where you came from. If you need a section of code to act like a function, you should use call where-as if you need a loop, then you should use goto . If you use call without returning too much, you will get a stack-overflow error. :myLoop println \"Hello\" goto myLoop :myFunc call myFunc ;Will cause a stack-overflow error since it is not returned :myFunc ;... do some processing ret call myFunc ;Will not cause an error, since ret is used Stack Manipulation The stack is the main method of storing data in SPL. push , pop and setpop are the main methods of moving data to and from the stack. push will add data onto the stack. It can take any data type, and variables. pop will remove data from the stack, but will not do anything with it so the data will be deleted. setpop will pop the data, but instead of deleting it, it will move it into a variable. push 1 push 2 pop setpop x println x ;1 will be printed since 2 got popped of the stack Maths SPL has numerous maths instructions. These will take values off of the stack, and will push a result back onto it. It is important to be aware that the order of pushing values is reversed from what you might expect. The left hand side will be popped first so make sure you push the right hand side first. Adding The add instruction will take two numeric values and push the result onto the stack. push 5 push 10 add setpop res ;res now stores 15 (10 + 5) Subtracting The sub instruction will take two numeric values and push the result onto the stack push 5 push 10 sub setpop res ;res now stores 5 (10 - 5) push 10 push 5 sub setpop res ;res now stores -5 (5 - 10) Multiplication The mul instruction will take two numeric values and push the result onto the stack push 5 push 10 mul setpop res ;res now stores 50 (10 * 5) Division The div instruction will take two numeric values and push the result onto the stack push 5 push 10 div setpop res ;res now stores 2 (10 / 5)","title":"Instructions"},{"location":"ops/#instructions","text":"","title":"Instructions"},{"location":"ops/#let","text":"The let keyword will update the value of a variable, or assign it if it does not exist. ;This will create x let x \"SPL\" let x \"New Value\" ;This will update the value of x All variables must be created before use. push x ;This will fail since x has not been created yet let x 1 push x ;This is ok because x has already been created","title":"Let"},{"location":"ops/#setpop","text":"setpop is similar to the let keyword, however it will take the value of the variable from the stack instead of being given an explicit value. push 3.1415 setpop pi ;pi now contains 3.1415 setpop will operate on variables that already exist and have not been defined push 0 let x 0 setpop x push 0 setpop y ;Even though y has not been defined, setpop will create it","title":"Setpop"},{"location":"ops/#print","text":"Printing uses two different keywords. print and println . As you might be able to guess from the name, println will print with a new line character appended at the end of the output. print \"Hello\" println \" There \" print \"World!\" ;This will display this in the console: ;Hello There ;World! Printing also works with all data types and variables let x \"Hello\" println x print \"Hello\" print 1 print 3.1415","title":"Print"},{"location":"ops/#calling","text":"SPL uses two keywords to deal with calling. goto and call are the two main instructions used. goto will jump to a set code point. call does the same, except it will add to the callstack which allows you to return back to where you came from. If you need a section of code to act like a function, you should use call where-as if you need a loop, then you should use goto . If you use call without returning too much, you will get a stack-overflow error. :myLoop println \"Hello\" goto myLoop :myFunc call myFunc ;Will cause a stack-overflow error since it is not returned :myFunc ;... do some processing ret call myFunc ;Will not cause an error, since ret is used","title":"Calling"},{"location":"ops/#stack-manipulation","text":"The stack is the main method of storing data in SPL. push , pop and setpop are the main methods of moving data to and from the stack. push will add data onto the stack. It can take any data type, and variables. pop will remove data from the stack, but will not do anything with it so the data will be deleted. setpop will pop the data, but instead of deleting it, it will move it into a variable. push 1 push 2 pop setpop x println x ;1 will be printed since 2 got popped of the stack","title":"Stack Manipulation"},{"location":"ops/#maths","text":"SPL has numerous maths instructions. These will take values off of the stack, and will push a result back onto it. It is important to be aware that the order of pushing values is reversed from what you might expect. The left hand side will be popped first so make sure you push the right hand side first.","title":"Maths"},{"location":"ops/#adding","text":"The add instruction will take two numeric values and push the result onto the stack. push 5 push 10 add setpop res ;res now stores 15 (10 + 5)","title":"Adding"},{"location":"ops/#subtracting","text":"The sub instruction will take two numeric values and push the result onto the stack push 5 push 10 sub setpop res ;res now stores 5 (10 - 5) push 10 push 5 sub setpop res ;res now stores -5 (5 - 10)","title":"Subtracting"},{"location":"ops/#multiplication","text":"The mul instruction will take two numeric values and push the result onto the stack push 5 push 10 mul setpop res ;res now stores 50 (10 * 5)","title":"Multiplication"},{"location":"ops/#division","text":"The div instruction will take two numeric values and push the result onto the stack push 5 push 10 div setpop res ;res now stores 2 (10 / 5)","title":"Division"},{"location":"walkthrough/","text":"Walkthrough This guide will assume that you have correctly installed or compiled SPL. Console The very first thing to teach is printing text to the console. SPL features two instructions for printing. println and print As you can probably guess, one of these will add a new line character on the end of the text print \"Hello, \" println \"World!\" ;Prints `Hello, World!` to the console Variables SPL supports variables. Variables are just a value in memory. Variables can either be mutable or constant. Mutable variables means that their value can be changed, whereas constant, means the value cannot be changed once set. let x \"Value\" ;Note that if this was const, an error would be thrown as constant values cannot be changed let x \"Another value\" const PI 3.1415 ;I am constant, therefore my value must be set at compile time and cannot be changed Variables can also be deleted using the free keyword. let i 0 free i push i ;This will cause an error since i no longer exists on the variable stack Variable Types SPL currently supports 3 different variable types. The first is integers. These are numbers which contain no decimal value. Second is floating point numbers. These are numbers which contain a decimal value Lastly is strings. Strings are sequences of characters, although note that SPL contains no char type, and you cannot read a certain value from strings. Variables in SPL are dynamically typed which means their value will be determined at run-time and the variable type can be re-assigned by writing a new value to a variable. Stack SPL features a stack where you can move values onto. This is mostly used to simulate function parameters, or for maths operations. You can use push or pop to add or remove values. push 2 push 1000 div setpop res print \"1000 / 2 is \" println res Looping SPL can also move around the current execution. There are two ways of doing this. call will take a label name and jump to it. It also adds to the callstack, meaning you can return using the ret keyword.goto will jump without touching the callstack. By using goto, you don't just need a label name, but you can also jump to a line number println \"Hello\" goto 1 Using labels, we can do it this way :loop println \"Hello\" goto loop Be careful though, using call, it will add to the callstack, like a function call, meaning this code will create a stack overflow error. :loop println \"Hello\" call loop ;This will throw an stack overflow Using ret allows us to jump back to a previous location. If you return when there is nowhere to return to, then an error will throw call loop :loop println \"Hello\" ret ;This will only execute once, as we are returning out of this call goto loop","title":"Walkthrough"},{"location":"walkthrough/#walkthrough","text":"This guide will assume that you have correctly installed or compiled SPL.","title":"Walkthrough"},{"location":"walkthrough/#console","text":"The very first thing to teach is printing text to the console. SPL features two instructions for printing. println and print As you can probably guess, one of these will add a new line character on the end of the text print \"Hello, \" println \"World!\" ;Prints `Hello, World!` to the console","title":"Console"},{"location":"walkthrough/#variables","text":"SPL supports variables. Variables are just a value in memory. Variables can either be mutable or constant. Mutable variables means that their value can be changed, whereas constant, means the value cannot be changed once set. let x \"Value\" ;Note that if this was const, an error would be thrown as constant values cannot be changed let x \"Another value\" const PI 3.1415 ;I am constant, therefore my value must be set at compile time and cannot be changed Variables can also be deleted using the free keyword. let i 0 free i push i ;This will cause an error since i no longer exists on the variable stack","title":"Variables"},{"location":"walkthrough/#variable-types","text":"SPL currently supports 3 different variable types. The first is integers. These are numbers which contain no decimal value. Second is floating point numbers. These are numbers which contain a decimal value Lastly is strings. Strings are sequences of characters, although note that SPL contains no char type, and you cannot read a certain value from strings. Variables in SPL are dynamically typed which means their value will be determined at run-time and the variable type can be re-assigned by writing a new value to a variable.","title":"Variable Types"},{"location":"walkthrough/#stack","text":"SPL features a stack where you can move values onto. This is mostly used to simulate function parameters, or for maths operations. You can use push or pop to add or remove values. push 2 push 1000 div setpop res print \"1000 / 2 is \" println res","title":"Stack"},{"location":"walkthrough/#looping","text":"SPL can also move around the current execution. There are two ways of doing this. call will take a label name and jump to it. It also adds to the callstack, meaning you can return using the ret keyword.goto will jump without touching the callstack. By using goto, you don't just need a label name, but you can also jump to a line number println \"Hello\" goto 1 Using labels, we can do it this way :loop println \"Hello\" goto loop Be careful though, using call, it will add to the callstack, like a function call, meaning this code will create a stack overflow error. :loop println \"Hello\" call loop ;This will throw an stack overflow Using ret allows us to jump back to a previous location. If you return when there is nowhere to return to, then an error will throw call loop :loop println \"Hello\" ret ;This will only execute once, as we are returning out of this call goto loop","title":"Looping"}]}